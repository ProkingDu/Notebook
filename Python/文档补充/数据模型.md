
## 对象、值与类型

在python中一切的数据都是由`对象`或者`对象间的关系`来表示的。

在 CPython 中，`id(x)` 就是存放 `x` 的内存的地址。

对象的类型决定了对象可以支持的操作，可以通过`type()`来查看对象的类型，实际上`type()`返回的类型也是一个对象。

对象分为可变对象与不可变对象，区分的依据是对象的值是否`直接可以更改`,可变对象的值是可以直接更改的，但是不可变对象不是严格的不可更改，由于存在引用关系，当一个不可变对象引用一个可变对象时，当可变对象的值改变，不可变对象的值也会改变。

一个对象的可变性是由其类型决定的；例如，数字、字符串和元组是不可变的，而字典和列表是可变的。

对象绝不会被**显式地销毁**；然而，当无法访问时它们可能会被作为垃圾回收。允许具体的实现推迟垃圾回收或完全省略此机制 --- 如何实现垃圾回收是实现的质量问题，只要可访问的对象不会被回收即可。

有些对象包含对其他对象的引用；它们被称为 _容器_。容器的例子有元组、列表和字典等。

类型会影响对象行为的几乎所有方面。

对于`不可变类型`，在产生新值时可能会创建一个新的对象，或者是对现有的可用的相同类型的对象的引用，但是这在`可变对象`中是**绝不允许的**。两个值相同的可变对象也一定会指向两个不同的对象。

很直观的例子：
当创建两个值相同的元组时，他们的内存地址是相同的，当创建两个值相同的列表时，他们的内存地址是不同的。

```
t1 = (1,2,3)

t2 = (1,2,3)

  

print(id(t1),id(t2))

  

d1=[1,2,3]

d2=[1,2,3]

print(id(d1),id(d2))

'''
4407353984 4407353984
4407298688 4407354112
'''
```

如果对上面的t2采用某种方法修改，再打印出内存地址则会发现t2的内存地址变化了，且没有对t1产生影响。


## 标准类型层级结构

### None

None类型下只有一种取值，并且通过关键字None来访问，它通常用来代表空值，且没有默认返回值的函数会返回此类型。

**None的布尔类型是False**


### NotImplemented

一个应当由双目运算特殊方法（如 [`__eq__()`](https://docs.python.org/zh-cn/3/reference/datamodel.html#object.__eq__ "object.__eq__"), [`__lt__()`](https://docs.python.org/zh-cn/3/reference/datamodel.html#object.__lt__ "object.__lt__"), [`__add__()`](https://docs.python.org/zh-cn/3/reference/datamodel.html#object.__add__ "object.__add__"), [`__rsub__()`](https://docs.python.org/zh-cn/3/reference/datamodel.html#object.__rsub__ "object.__rsub__") 等）返回的特殊值，用来表明该运算没有针对其他类型的实现。

`NotImplemented` 是 [`types.NotImplementedType`](https://docs.python.org/zh-cn/3/library/types.html#types.NotImplementedType "types.NotImplementedType") 类型的唯一实例。

常用于自定义数据类型的算数运算中的参数非本类的实例而无法进行双目运算而返回的值。

当NotImplemented被返回时，解释器会尝试对另一种类型进行反射操作，当两种类都返回所有尝试都返回 `NotImplemented`，解释器将引发适当的异常。

一个简单的例子：
```py
class Inter:  
    def __init__(self,value):  
        self.value=value  
    def __add__(self,other):  
        if not isinstance(other,Inter):  
            return NotImplemented  
        return self.value+other.value  
         
class Intee:  
    def __init__(self,value):  
        self.value=value  
    def __add__(self,other):  
        if not isinstance(other,Intee):  
            # return NotImplemented  
            pass  
        return self.value+other.value  
       
a=Inter(10)  
b=Intee(20)  
print(a+b)
```
由于b不是Inter类的实例，所以在进行运算时抛出Notimplemented，在最近的Python版本中这会产生一个TypeError


### 