## 1.pinMode()
用于设置数字引脚的输入输出模式
参数：
* pin  引脚号
* mode 模式 INPUT、OUTPUT、INPUT_PULLUP等

三种输入输出模式：
### INPUT模式

当引脚设置为输入（INPUT）模式时，引脚为高阻抗状态（100兆欧）。此时该引脚可用于读取传感器信号或开关信号。

***Link:高阻抗状态***
> 高阻态是一个数字电路里常见的术语，指的是电路的一种输出状态，**既不是高电平也不是低电平**，如果高阻态再输入下一级电路的话，对下级电路无任何影响，和没接一样，类似于引脚悬空，如果用万用表测的话有可能是高电平也有可能是低电平，随它后面接的东西定。
>   **处于高阻抗状态时，输出电阻很大，相当于开路，没有任何逻辑控制功能。** 高阻态的意义在于 **实际电路中不可能断开电路。** 三态电路的输出逻辑状态的控制，是通过一个输入引脚实现的。

***Link:电路的三态：***
> #### 三种状态：
> ##### 1. 高电平
>   在数字电路中高电平指输出1的信号，即此时针脚接受5V（针对ARduino，不同的单片机这个数值也不同。）电压。
> ##### 2. 低电平
>   与高电平相反，在低电平状态输出0的信号，相当于针脚不通电。
> ##### 3. 高阻态
>   即上诉的一种特殊的输出状态，既不是高电平也不是低电平，可用于读取数字电路信号。


**注意：当Arduino引脚设置为输入（INPUT）模式或者输入上拉（INPUT_PULLUP）模式，请勿将该引脚与负压或者高于5V的电压相连，否则可能会损坏Arduino控制器。**


### OUTPUT模式
当引脚设置为输出（OUTPUT）模式时，引脚为**低阻抗状态**。这意味着Arduino**可以向其它电路元器件提供电流**。也就是说，Arduino引脚在输出（OUTPUT）模式下可以点亮LED或者驱动电机。（如果被驱动的电机需要超过40mA的电流，Arduino将需要三极管或其它辅助元件来驱动他们。）

***Link:低阻抗状态：***
> 与高阻抗状态相反，低阻抗状态是较低的阻抗，此时输出电阻很小，意味着引脚对应的元件可以向其他元器件输出电流。

***Link:阻抗***
> 在具有电阻、电感和电容的电路里，对电路中的电流所起的阻碍作用叫作阻抗。
> 阻抗包含电阻和电抗。在物理中用Z表达，是一个复数，实部为电阻，虚部为电抗。

当针脚处于OUTPUT mode时，可以通过`digitalWrite()`函数来输出高低电平控制通电。

例如ARduino开发板上对应的13号针脚一个LED灯片，通过:
```C
pinMode(13,OUTPUT); //输出状态
digitalWrite(13,HIGH);   //输出高电平
delay(1000);    // 暂停一秒
digitalWrite(13,LOW);  //输出低电平
delay(1000)   //暂停
```

当灯片对应的针脚是OUTPUT模式时，可以对其输出高低电平，由于此时处于低阻抗状态，针脚可以为LED灯提供电流，当给定高电平信号时，在电路中输出5V的电压，点亮灯泡。

### INPUT_PULLUP 模式
Arduino 微控制器自带内部上拉电阻。如果你需要使用该内部上拉电阻，可以通过pinMode()将引脚设置为输入上拉（INPUT_PULLUP）模式。

上拉电阻是当某输入端口未连接设备或处于高阻抗的情况下，一种用于保证输入信号为预期逻辑电平的电阻元件。

在上拉电阻连接的导线中，当外部元器件没有启用的时候，上拉电阻微弱地将电压信号拉高，这时候对于输入端来说，外部就相当于高阻抗的状态（对应INPUT）。此时通过上拉电阻将输入端口处的电压拉高到高电平。如果外部端口被启用，则此时高电平被取消。通过这种方法，上拉电阻可以使外部即使没有连接组件的情况下也能保持确定的逻辑电平。


## 2.digitalWrite()
`digitalWrite(pin,value)` 用于向数字引脚写入高低电平。
参数：
* pin 数字针脚编号
* value HIGH或者LOW。

针对pinMode的不同值HIGH和LOW有不同的表现。

### 当pinMode为OUTPUT时
此时引脚为低阻值状态，当digitalWrite()对针脚写入HIGH时，其电压将被设置为5V（高电平，具体电压根据不同开发板决定），当写入LOW时，电压将被设置为0V（接地）。

简单来说，在OUTPUT状态下HIGH为输出高电平，LOW为输出低电平。

### 当pinMode为INPUT时
由于INPUT时引脚处于高阻值状态，高阻值状态不能直接输出电流，所以当向针脚写入HIGH时表示启用内部上拉，而LOW时则为关闭内部上拉。

实际上在设置为HIGH时，与`pinMode(pin,INPUT_PULLUP)`等效，而在LOW时又处于高阻态，又关闭了内部上拉，没有什么意义。

### 当pinMode为INPUT_PULLUP时

首先INPUT_PULLUP时，在外部没有启用元器件的时候，内部处于高阻值状态，并且通过内部上拉电阻将输入端口处的电压拉高到5V（高电平），如果再通过digitalWrite()将其设置为高电平，相当于将原先的高电平替换，且这时候原先的内部上拉产生的高电平被取消。

其次，当向针脚设置低电平的时候，INPUT_PULLUP实际上就是原先的通过内部上拉电阻实现的高电平。再对其输出为低电平，相当于取消之前通过内部上拉设置的高电平，并且替换为低电平。

实际上在元件中的表现，INPUT_PULLUP与OUTPUT+HIGH的效果表现是相似的。


代码实现：
```C
#define LED 13
void setup() {
  pinMode(LED,INPUT_PULLUP);  // 设置引脚为INPUT_PULLUP

  // 启用串口监视
  Serial.begin(19200);

  delay(2000);

  Serial.println("输出高电平");

   // 输出高电平
  digitalWrite(LED,HIGH);
  
  delay(2000);

  // 输出低电平
  Serial.println("输出低电");

  digitalWrite(LED,LOW);
}
```

13号针脚对应开发板上的LED灯，在将程序烧录之后立马设置引脚为INPUT_PULLUP模式，发现LED灯点亮，这就相当于：
```C
void setup()
{
    pinMode(13,OUTPUT);
    digitalWrite(13,HIGH);
}
```

之后延时两秒设置高电平，LED灯仍然点亮，但是在内部是取消了通过内部上拉电阻产生的高电平。（这里是我自己认为的，没有找到权威的解答，蹲一个大佬答疑。）

最后再延迟两输出低电平，此时LED灯熄灭。

对INPUT模式下的HIGH和LOW测试：
```C
void setup(){
  pinMode(13,INPUT);  // 设置引脚为INPUT模式，处于高祖值状态，这时候LED灯熄灭，因为没有接受信号
  delay(2000);
  // 输出高电平，启用内部上拉，这时候电压被拉升到5V
  digitalWrite(13,HIGH);
  delay(2000);
  // 输出低电平，关闭内部上拉，接地
  digitalWrite(13,LOW);
}
```

表现为：开机后LED灯不亮，两秒后点亮，点亮两秒后熄灭。


## 3.digitalRead()
用于读取指定针脚的电平，当针脚有一个高电平时，该函数返回1,当针脚为低电平时，返回0.
尝试在ARduino开发板上通过1释放高电平在与2针脚连接，读取2针脚的值，发现接线在S、V、G三种针出现不同效果。

这里扩展一下：
### 开发板上的S：
> 指I/O口，I/O 接口，或者是 I/O 控制器，是主机和外设之间地交接界面，通过接口可以实现主机和外设之间地信息交换。主机和外设具有各自工作特点，它们在信息形式和工作速度具有很大地差异，接口就是为了解决这些差异而设置的。
> 详见：https://blog.csdn.net/qq_42896653/article/details/105418001  （引用文章）
>

### 开发板上的V、G:
> 指VCC。VCC和GND两者在开发中经常=配合使用。
> VCC是指电路的供电电压，GND指电路的接地端，是开发板里面总的地线。
> 在电路连接中将VCC通过杜邦线连接正极，将GND连接负极，这样才能形成一个完整的电路。
> 这二者是模拟电路中的概念，对应的还有数字电路中的VDD、VSS。
> VDD表示数字信号的电源，VSS表示数字信号的地。

所以针对上面遇到的情况来分析，先看代码：
```C
  // 尝试读取引脚电平。
  Serial.begin(19200);
  pinMode(1,OUTPUT);
  digitalWrite(1,HIGH);
  int v=digitalRead(2);
  Serial.println(v);
```
我对1针脚输出高电平，然后连接1和2针脚。

当1针脚的G连接二针脚的G时，二者都是地，这个电路是错误的并且没有供电端，所以运行结果输出0.

由于G脚是接地的，所以他不能用于读取电平，直接跳过和其他脚组合。（实际上已经测试了，接V会短路，但还没搞清原因，接S没有响应。）

第二种组合：V->V 两个供电端连接，没有短路，但是读取到的电平是低电平。

第三种：S->V 一样输出是0.

最后尝试一针脚接V二针脚接S，输出1说明针脚2得到了高电平。

如果通过外部传入的高电平信号，应该通过接S脚来读取。

但是有个奇怪的问题，接1脚的时候无论是否给高电平2脚都能读到高电平，但是其他的脚不给高电平2脚也没有得到高电平。

## 4.analogWrite()
`analogWrite()`用于向数字引脚输出模拟信号，也就是PWM（脉冲宽度调制）信号。PWM信号是通过高低电平的占空比来模拟出不同电平值的信号。关于PWM在后面详写。

该函数需要两个参数：引脚号和值。引脚号是数字引脚的编号，值可以是0到255之间的整数。

如果引脚已经被设置为输出模式，且支持 PwM输出，那么调用 analogwrite（）函数会在该引脚上输出一个PWM信号。值参数指定了 PWM 信号的占空比，即高电平信号所占的时间与一个周期的时间之比。例如，如果值为128，则高电平和低电平信号各占一半的时间，输出的是一个50％的占空比的PWM信号。

PWM经常用于控制LED的亮度、马达的转速等需要模拟输出的场合。

## 5.analogRead()
`analogRead()`用于读取模拟引脚上的模拟信号。

Arduino控制器有多个10位数模转换通道。这意味着Arduino可以将0－5伏特的电压输入信号映射到数值0－1023。

换句话说，我们可以将5伏特等分成1024份。0伏特的输入信号对应着数值0，而5伏特的输入信号对应着1023。

例：
当模拟输入引脚的输入电压为2.5伏特的时候，该引脚的数值为512。
(2.5伏特 / 5伏特 = 0.5， 1024 X 0.5 ?＝512)

当模拟输入引脚的输入电压为1V时，引脚的数值为：
1/5 * 1024 ?= 205

引脚的输入范围以及解析度可以使用`analogReference()`指令进行调整。

Arduino控制器读取一次模拟输入需要消耗100微秒的时间（0.0001秒）。控制器读取模拟输入的最大频率是每秒10，000次。

**注意：在模拟输入引脚没有任何连接的情况下，用analogRead()指令读取该引脚，这时获得的返回值为不固定的数值。这个数值可能受到多种因素影响，如将手靠近引脚也可能使得该返回值产生变化。**

语法：
```
analogRead(pin)
```

* pin 针脚号

在ARduino开发板上模拟引脚通常用Ax标注，其中x为引脚编号的数字部分。

例如读取A1引脚的模拟信号：
```
int value=analogRead(A0);
```

## 6.analogReference()

`analogReference()`用于配置用于模拟输入的基准电压/参考电压（即输入范围的最大值）。

参数：

* DEFAULT：默认5V或3.3V为基准电压。

* INTERNAL：在ATmega168和ATmega328上以1.1V为基准电压，以及在ATmega8上以2.56V为基准电压（Mega2560无此选项）

* INTERNAL1V1：以1.1V为基准电压（此选项仅针对Mega2560）

* INTERNAL2V56：以2.56V为基准电压（此选项仅针对Mega2560）

* EXTERNAL：以AREF引脚（0至5V）的电压作为基准电压。

一般在Arduino中较少使用更改。


## 7.delay()
`delay()`即时延函数，参数为ms，在执行到此函数时程序将停止若毫秒。

注意：delay()的时延会阻塞程序的运行，所以在这个时延完成之后其他的程序都不会被执行，如果需要暂停期间仍然保持程序的响应，可以使用非阻塞时延技术，例如`millis()`函数

关于millis会在后面具体介绍。

## 8.delayMicroseconds()
与delay()相同，单位为微秒。
1s=1000ms=1000000us

## 9.串口监视器和串口绘图仪的使用

### 1.启用串口监视
使用`Serial.begin(pwm)`来启用串口监视，启用之后可以通过Arduino IDE来进行串口数据监视和发送串口数据。

* pwm 波特率，指定不同的波特率在串口也要对应不同的波特率。

![小杜的个人图床](http://src.xiaodu0.com/2023/12/22/ad2f48d96cd1250b9913a021ebb87e1a.png)


### 2.串口打印
通过`Serial.println()`来对串口输出数据，数据输出后通过串口监视器可以读取。

但是需要注意在PC上的波特率要和Serial.begin中的波特率对应否则会乱码。

例如：
```C
void setup(){
  Serial.begin(19200);
  String data="Bye world.";
  Serial.println(data);
}
```

串口监视器：

![小杜的个人图床](http://src.xiaodu0.com/2023/12/22/950f7e79ec6dffe822c231353c35b2df.png)

### 3.通过单片机接收数据
通过`Serial.readString()`来读取串口输入数据是非常方便的调试方法，通过接收数据配合流程控制可以实现很多调试功能。

例如通过串口通信控制LED灯亮灭：
```C
#define LED 13
void setup(){
  Serial.begin(19200);
  pinMode(LED,OUTPUT);
}

void loop() {
  String data=Serial.readString();
  data.trim();
  if(data=="ON"){
    digitalWrite(LED,HIGH);
    Serial.println("已开启LED灯");
  }else if(data=="OFF"){
    digitalWrite(LED,LOW);
    Serial.println("已关闭LED灯");
  }
}
```

![小杜的个人图床](http://src.xiaodu0.com/2023/12/22/4e70fb12e00185f0954cc2fba5985560.png)


### 4.串口绘图仪的使用
串口绘图仪可以将单片机输出的数据绘制成折线图，方便通过直观的数据变化来 调试项目。

例如，在上面的示例程序再加上通过发送STOP和START控制输出A1模拟引脚的模拟信号，并在串口绘图仪展示A1模拟引脚上的模拟信号的变化。

```C
#define LED 13
int status=1;
void setup(){
  Serial.begin(19200);
  pinMode(LED,OUTPUT);

}

void loop() {
  String data=Serial.readString();
  data.trim();
  if(data=="ON"){
    digitalWrite(LED,HIGH);
    Serial.println("已开启LED灯");
  }else if(data=="OFF"){
    digitalWrite(LED,LOW);
    Serial.println("已关闭LED灯");
  }

  // 读取引脚模拟信号
  int value=analogRead(A1);
  // 判断输入
  if(data=="STOP"){
    status=0;
    Serial.println("已停止输出。");
  }else if(data=="START"){
    status=1;
  }

  if(status==1){
    Serial.println(value);
  }
}
```

![小杜的个人图床](http://src.xiaodu0.com/2023/12/22/c67c4902682f37ba56aba3c88e18872c.png)

![小杜的个人图床](http://src.xiaodu0.com/2023/12/22/2a931460de3afde98368465b9c66b07e.png)

为什么这里A1的模拟信号会不断变化呢？
请看上面analogRead()函数相关！


