
## 对象、值与类型

在python中一切的数据都是由`对象`或者`对象间的关系`来表示的。

在 CPython 中，`id(x)` 就是存放 `x` 的内存的地址。

对象的类型决定了对象可以支持的操作，可以通过`type()`来查看对象的类型，实际上`type()`返回的类型也是一个对象。

对象分为可变对象与不可变对象，区分的依据是对象的值是否`直接可以更改`,可变对象的值是可以直接更改的，但是不可变对象不是严格的不可更改，由于存在引用关系，当一个不可变对象引用一个可变对象时，当可变对象的值改变，不可变对象的值也会改变。

一个对象的可变性是由其类型决定的；例如，数字、字符串和元组是不可变的，而字典和列表是可变的。

对象绝不会被**显式地销毁**；然而，当无法访问时它们可能会被作为垃圾回收。允许具体的实现推迟垃圾回收或完全省略此机制 --- 如何实现垃圾回收是实现的质量问题，只要可访问的对象不会被回收即可。

有些对象包含对其他对象的引用；它们被称为 _容器_。容器的例子有元组、列表和字典等。

类型会影响对象行为的几乎所有方面。

对于`不可变类型`，在产生新值时可能会创建一个新的对象，或者是对现有的可用的相同类型的对象的引用，但是这在`可变对象`中是**绝不允许的**。两个值相同的可变对象也一定会指向两个不同的对象。

很直观的例子：
当创建两个值相同的元组时，他们的内存地址是相同的，当创建两个值相同的列表时，他们的内存地址是不同的。

```
t1 = (1,2,3)

t2 = (1,2,3)

  

print(id(t1),id(t2))

  

d1=[1,2,3]

d2=[1,2,3]

print(id(d1),id(d2))

'''
4407353984 4407353984
4407298688 4407354112
'''
```

如果对上面的t2采用某种方法修改，再打印出内存地址则会发现t2的内存地址变化了，且没有对t1产生影响。


## 标准类型层级结构

### None

None类型下只有一种取值，并且通过关键字None来访问，它通常用来代表空值，且没有默认返回值的函数会返回此类型。

**None的布尔类型是False**


### NotImplemented

一个应当由双目运算特殊方法（如 [`__eq__()`](https://docs.python.org/zh-cn/3/reference/datamodel.html#object.__eq__ "object.__eq__"), [`__lt__()`](https://docs.python.org/zh-cn/3/reference/datamodel.html#object.__lt__ "object.__lt__"), [`__add__()`](https://docs.python.org/zh-cn/3/reference/datamodel.html#object.__add__ "object.__add__"), [`__rsub__()`](https://docs.python.org/zh-cn/3/reference/datamodel.html#object.__rsub__ "object.__rsub__") 等）返回的特殊值，用来表明该运算没有针对其他类型的实现。

`NotImplemented` 是 [`types.NotImplementedType`](https://docs.python.org/zh-cn/3/library/types.html#types.NotImplementedType "types.NotImplementedType") 类型的唯一实例。

常用于自定义数据类型的算数运算中的参数非本类的实例而无法进行双目运算而返回的值。

当NotImplemented被返回时，解释器会尝试对另一种类型进行反射操作，当两种类都返回所有尝试都返回 `NotImplemented`，解释器将引发适当的异常。

一个简单的例子：
```py
class Inter:  
    def __init__(self,value):  
        self.value=value  
    def __add__(self,other):  
        if not isinstance(other,Inter):  
            return NotImplemented  
        return self.value+other.value  
         
class Intee:  
    def __init__(self,value):  
        self.value=value  
    def __add__(self,other):  
        if not isinstance(other,Intee):  
            # return NotImplemented  
            pass  
        return self.value+other.value  
       
a=Inter(10)  
b=Intee(20)  
print(a+b)
```
由于b不是Inter类的实例，所以在进行运算时抛出Notimplemented，在最近的Python版本中这会产生一个TypeError


### Ellipsis

此类型只有一种取值。是一个具有此值的单独对象。此对象通过字面值 `...` 或内置名称 `Ellipsis` 访问。它的逻辑值为真。

Ellipsis是Ellipsis类的唯一实例，他表示的就是省略的意思，一般用于切片中省略切片索引或者在类型注解中省略对某个或者某些返回值的类型注解省略。

但是注意：***切片中`...`只能在切片时出现一次，且只能在左右或者中间出现。***

例如：
```python
import numpy as np  
  
data=np.random.rand(3,3,3)  


print(data[1,1,1])
// 0.7506220798226089
print(data[1,...,2]) 
// [0.70062679 0.47419978 0.96818501]
print(data[1,Ellipsis,1])  // 同上
```
创建一个三维向量，截取第二个向量中的每个子向量的第二列。

注解：
```python
class User:  
    def __init__(self, account: int | str, password: str):  
        print("登录失败")  
  
    def getInfo(self, uid: int) -> (str, int, ...):  
        return "name", 18, "19999999999"
```



### numbers.Number

numbers模块定义了数字抽象基类的的层级结构，其中逐级定义了更多的操作。 此模块中定义的类型都不可被实例化。

此类对象由数字字面值创建，并会被作为算术运算符和算术内置函数的返回结果。数字对象是不可变的；一旦创建其值就不再改变。Python 中的数字当然非常类似数学中的数字，但也受限于计算机中的数字表示方法。

- 它们是有效的数字字面值，当被传给它们的类构造器时，将会产生具有原数字值的对象。
    
- 表示形式会在可能的情况下采用 10 进制。
    
- 开头的零，除小数点前可能存在的单个零之外，将不会被显示。
    
- 末尾的零，除小数点后可能存在的单个零之外，将不会被显示。
    
- 正负号仅在当数字为负值时会被显示。

#### numbers.Integral




