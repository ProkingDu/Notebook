
## 开发调试记录


目前完成的部分是首先将图像灰度之后，使用canny边缘检测提取边缘图像，然后通过高斯滤波来减少噪声的影响（由于是在室外，在有阳光的情况下噪声格外的多） 然后通过ROI区域的逻辑与运算保留ROI内的边缘线条，再通过霍夫变换来检测直线。

得到赛道边缘的直线之后，接下来还要通过离群值过滤和最小二乘拟合来提取最贴近赛道的完整直线便于接下来通过划分ROI区域计算中线和拟合中线曲率计算运动轨迹。这一部分目前还没有开始做。

之前保存了车子摄像头在操场实录的画面，就直接用这些画面来做调试了。

首先开启一个视频流对象，读取视频内容，在实际调试的时候这里可以换成摄像头编号。
由于需要通过灰度图来进行边缘检测，这里将原始的BGR图像转为GRAYSCALE，并且重设尺寸为640\*480,。
同时为了减少计算量和顶部无用图像对计算的影响，对图像进行部分裁剪。

```python
# 加载图片  
cap = cv2.VideoCapture("img/demo.mp4")  
# img = cv2.imread("img/img_2.png",cv2.IMREAD_GRAYSCALE)  
  
while True:  
    ret, img = cap.read()  
    img = cv2.cvtColor(img,cv2.COLOR_BGR2GRAY)  
    # 重设尺寸  
    img_raw_gray = cv2.resize(img,(640,480))  
  
    # 裁剪图像  
    img_rect_gray = img_raw_gray[int(img_raw_gray.shape[0]//2):,:]  
    cv2.imshow("灰度图像",img_rect_gray)
```

![小杜的个人图床](http://src.xiaodu0.com/2024/09/21/a1a6a1ed72824f73017add55573c3e1b.png)


使用高斯模糊消除噪声：
```python
# 在边缘检测之前使用高斯模糊来消除噪声  
blur_img = cv2.GaussianBlur(img_rect_gray,(7,7),0)  
cv2.imshow("高斯模糊图像",blur_img)
```
![小杜的个人图床](http://src.xiaodu0.com/2024/09/21/5b7068d0a8906ea0b30a23b47963585d.png)

然后进行边缘检测：
```python
# canny边缘检测  
canny_img = cv2.Canny(blur_img,25,100)  
cv2.imshow("边缘图像",canny_img)
```
这里对比下应用高斯滤波前后的差异：

![小杜的个人图床](http://src.xiaodu0.com/2024/09/21/bc61e6d64c610bb23d14b88c8329f2a5.png)


![小杜的个人图床](http://src.xiaodu0.com/2024/09/21/e07fa1ba0de57547e169f86c7642effe.png)

可以看到由于阳光照射地面反光的影响，底部有非常多的噪点。

起初我觉的不使用高斯滤波而是直接通过霍夫变化提取直线，调大minLineLength也能去除噪声，显然我天真了：
![小杜的个人图床](http://src.xiaodu0.com/2024/09/21/14baa468bf85ea6f83438ea3d1a22393.png)



接着选取ROI区域，由于还没有去操场实测，现在ROI区域划分的还是比较大，这一部分通过绘制一个梯形的纯白图像，然后和之前的边缘图像进行逻辑与运算，即可保留ROI内的边缘：
```python
# 选取ROI  
roi = np.zeros_like(canny_img,dtype=canny_img.dtype) # 我是纸张，这里应当和canny_img类型相同  
# 绘制全白矩形  
cv2.fillPoly(roi,np.array([[[0,30],[600,30],[640,240],[0,240]]]),255)  
cv2.imshow("roi",roi)  
  
# 逻辑与运算，提取ROI内线条  
canny_after_roi = cv2.bitwise_and(canny_img,roi)  
cv2.imshow("ROI边缘图像",canny_after_roi)
```

![小杜的个人图床](http://src.xiaodu0.com/2024/09/21/211f63c4085a8ae947742e39cac52017.png)

![小杜的个人图床](http://src.xiaodu0.com/2024/09/21/d03f4bd1aacecb0d38a20b10b7f51d19.png)![小杜的个人图床](http://src.xiaodu0.com/2024/09/21/7b839a3833d23e79f2cba3e9a867a250.png)



最后通过霍夫变换提取直线，并且在原始的灰度图中绘制出来：
```python
# 使用霍夫变换提取直线  
lines = cv2.HoughLinesP(canny_after_roi, 1, np.pi / 180, 15, minLineLength=100, maxLineGap=10)  
print(lines[0][0])  
left_line = right_line = []  
for line in lines:  
    # 在原始图像上绘制直线  
    cv2.line(img_rect_gray, (line[0][0], line[0][1]), (line[0][2], line[0][3]), 255, 2)  
    if calculate_slope(line) > 0:  
        left_line.append(line)  
    elif calculate_slope(line) < 0:  
        right_line.append(line)  
# 展示绘制直线后的图像  
cv2.imshow("绘制直线后的图像", img_rect_gray)
```

![小杜的个人图床](http://src.xiaodu0.com/2024/09/21/6454bd757c51e48ebe6f22382a00865e.png)


目前完成的只有这些，从最后的图像也可以很明显的看出来，直接的霍夫变化会将较远处的直线也提取出，接下来主要需要优化的就是这一部分，尽量保证最后提取的直线只在最近的两个跑道了，这里需要到操场上重新录制一份车辆在跑道中间的图像，调整一下ROI区域和霍夫变化的参数。

## 知识扩充

把上面用到的一些方法记录一下，以便以后遗忘的时候查阅。

### 高斯滤波

高斯滤波通过一个高斯核（也称作高斯滤波器）来卷积图像，高斯核是一个权重矩阵，其中的权重值按照高斯分布来设置。高斯分布具有中心权重较大，离中心越远权重越小的特点，这使得滤波器在处理图像时能够更多地保留中心像素的信息，同时减少周围像素的影响。

语法：
```python
cv2.GaussianBlur(img,k_size,sigmaX,sigmaY,borderType)
```

其中ksize指定高斯卷积核，他是一个权重矩阵，形如（3,3）并且只能是奇数。
sigmaX和sigmaY是在X轴和Y轴的标准差，一般让opencv自动计算即可，默认为0即自动计算。
borderType指边界处理方式，默认为`cv2.BORDER_DEFAULT`
可能的值：
- `cv2.BORDER_REPLICATE`：重复边缘像素。
- `cv2.BORDER_REFLECT`：反射边缘像素。
- `cv2.BORDER_WRAP`：循环边缘像素。
- `cv2.BORDER_DEFAULT`：默认处理方式。

高斯滤波的效果取决于 `kernel_size` 和 `sigma` 的选择。通常较大的 `kernel_size` 会产生更强的模糊效果，而较小的 `kernel_size` 会保留更多的细节。`sigma` 的选择会影响高斯核的分布，通常让 OpenCV 自动计算 `sigma` 就足够了。


### 边缘检测

Canny 边缘检测算法是一种经典的边缘检测技术，广泛应用于图像处理和计算机视觉领域。OpenCV 提供了 `cv2.Canny()` 函数来实现 Canny 边缘检测算法。Canny 算法的目标是在保留有意义的边缘的同时去除噪声，并尽量保持边缘的连续性和准确度。

语法：
```python
cv2.Canny(image, threshold1, threshold2[, edges[, apertureSize[, L2gradient]]])
```

**参数说明**：

- **image**：输入图像，通常为灰度图像。
- **threshold1**：低阈值（Lower threshold），用于确定弱边缘。
- **threshold2**：高阈值（Upper threshold），用于确定强边缘。
- **edges**：输出的边缘图像，通常不需要指定。
- **apertureSize**：Sobel 梯度算子的大小，默认为 3。
- **L2gradient**：是否使用 L2 范数计算梯度幅度，默认为 False，使用 L1 范数。

Canny 边缘检测的效果很大程度上取决于 `low_threshold` 和 `high_threshold` 的选择。通常，`low_threshold` 的值是 `high_threshold` 的一定比例，比如 1/2 或 1/3。

- **low_threshold**：用于确定弱边缘的阈值。较低的阈值可能会引入更多的噪声。
- **high_threshold**：用于确定强边缘的阈值。较高的阈值可能会丢失一些重要的边缘信息。

**较小的sobel梯度算子能够更好的捕捉边缘细节，但是受噪声的影响比较大。较大的sobel算子则会使图像处理更加平滑，但是可能会丢失精细的边缘细节。**

### 绘制图形

使用fillPoly方法在图像中绘制图形。

```python
cv2.fillPoly(img, pts, color[, lineType[, shift]])
```


- **img**：目标图像，必须是 8 位或浮点类型的图像。
- **pts**：一个多边形顶点列表的列表。每个多边形顶点列表是一个由 `(x, y)` 坐标组成的数组。可以包含多个多边形的顶点。
- **color**：填充颜色。对于彩色图像，颜色为 `(B, G, R)` 形式的三元组；对于灰度图像，颜色为单个整数。
- **lineType**：线条类型，默认为 `cv2.LINE_8`。
- **shift**：坐标值的位移量，默认为 0。

注意：**这里的pts实际上应该是一个三维数组**
**常见的线条类型**：
1. **`cv2.LINE_8`**：
    - 默认的线条类型，使用 8 邻域来绘制线条。这意味着线条可以沿着 8 个方向（包括对角线方向）绘制。
2. **`cv2.LINE_4`**：
    - 使用 4 邻域来绘制线条。这意味着线条只能沿着水平和垂直方向绘制，而不包括对角线方向。
3. **`cv2.LINE_AA`**：
    - 使用抗锯齿（Anti-Aliasing）来绘制线条。这种类型可以产生更平滑的线条，但可能会稍微慢一些。
4. **`cv2.LINE_8 + cv2.LINE_AA`**：
    - 结合了 `LINE_8` 和 `LINE_AA` 的特性，可以在 8 邻域内绘制线条，并使用抗锯齿来平滑线条。
5. **`cv2.LINE_4 + cv2.LINE_AA`**：
    - 结合了 `LINE_4` 和 `LINE_AA` 的特性，只在 4 邻域内绘制线条，并使用抗锯齿来平滑线条。

### 霍夫变换

`cv2.HoughLinesP()` 是 OpenCV 中的一个函数，用于实现概率霍夫变换（Probabilistic Hough Transform），它专门用于检测图像中的直线段，特别是在存在许多无关点的情况下更为有效。

语法：
```python
lines = cv2.HoughLinesP(image, rho, theta, threshold[, lines[, minLineLength[, maxLineGap]]])
```

参数说明：
- image 要进行霍夫变换的二值图像
- rho 距离分辨率，单位是像素，常取1或者更大的整数
- theta 角度分辨率，单位是弧度。常取np.pi/180 即每度一个步长
- threshold 直线的霍夫投票阈值，只有当直线的投票数超过此阈值时，才会被保留。
- lines 可选参数，表示检测到的直线的输出数组。
- minLineLength 表示最小直线长度，只有当直线长度大于此值时才会被保留。
- maxLineGap 直线最大间隔，单位为像素，当两条直线之间的间隔小于此值时认为他们是同一条直线。

注意：
**霍夫变换返回的数组是一个三维数组，其中返回数组的每一个子数组是一个直线，每个子数组的第一个子数组是直线的起始坐标值和终点坐标值。**

