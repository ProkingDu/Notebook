# 第三节 虚拟主机基础

## 一、虚拟主机原理

### 1.虚拟主机访问原理

一台服务器可以有许多虚拟主机，而虚拟主机区分的标准就是配置文件中的server块和server_name配置项。
例如，访问n0.20fd.cn与n1.20fd.cn对应不同的虚拟主机，可以展示不同的站点，他的访问流程是:

用户在浏览器中输入域名访问，浏览器首先构造请求，然后查找本地DNS缓存，如果有缓存则通过缓存的地址向服务器建立连接和发送请求，如果没有缓存，即向本地hosts文件或DNS服务器获取域名对应的服务器地址，得到服务器地址和端口号之后，向服务器发送请求建立TCP连接，如果此时服务器的请求队列已满，就会进入TCP等待队列，反之通过三次握手建立TCP链接，建立TCP连接之后，浏览器向服务器发送请求包，服务器接收到请求包，调用中间件，这里讨论关于Nginx的处理，Nginx得到请求包之后，通过请求包中的Host请求头字段来决定调度哪一个虚拟主机，对应的是server块中的server_name配置项，Nginx将请求交给对应的虚拟主机处理，处理完成之后Nginx构造响应消息，并且返回到客服端浏览器，至此整个流程结束，服务器发起四次挥手断开TCP连接。

流程图：
![小杜的个人图床](http://pic.xiaodu0.com//assets/uploads/20231012/8702cd023d1b4546640422c89f40586a.png)

PS： 通常情况下，一旦服务器向客户端返回了请求数据，它就要关闭 TCP 连接。不过如果浏览器或者服务器在其头信息中加入了：Connection:Keep-Alive 那么 TCP 连接在发送后将仍然保持打开状态，这样浏览器就可以继续通过同一个 TCP 连接发送请求。保持 TCP 连接可以省去下次请求时需要建立连接的时间，提升资源加载速度。比如，一个 Web 页面中内嵌的图片就都来自同一个 Web 站点，如果初始化了一个持久连接，你就可以复用该连接，以请求其他资源，而不需要重新再建立新的 TCP 连接
### 2. 三次握手
1. **第一次握手**：客户端发送syn包(seq=x)到服务器，并进入SYN_SEND状态，等待服务器确认;

2. **第二次握手**：服务器收到syn包，必须确认客户的SYN(ack=x+1)，同时自己也发送一个SYN包(seq=y)，即SYN+ACK包，此时服务器进入SYN_RECV状态;

3. **第三次握手**：客户端收到服务器的SYN+ACK包，向服务器发送确认包ACK(ack=y+1)，此包发送完毕，客户端和服务器进入ESTABLISHED状态，标志请求已经建立完成。

握手过程中传送的包里不包含数据，三次握手完毕后，客户端与服务器才正式开始传送数据。理想状态下，TCP连接一旦建立，在通信双方中的任何一方主动关闭连接之前，TCP 连接都将被一直保持下去。

![小杜的个人图床](http://pic.xiaodu0.com//assets/uploads/20231012/47b4dc01b8f455b69c5e24af38237e72.png)

### 3.四次挥手
四次挥手发生在TCP 连接建立后，并且完成http请求流程之后，服务器主动发起的断开TCP连接的流程。

注意：四次挥手的发起方可以是客户端，也可以是服务端，只是在http协议中，通常由服务端发起关闭请求。

四次挥手的流程：
1. **第一次挥手：** 此时双方处于ESTABLISH状态，断开请求的发送方发送[FIN,ACK]数据包，数据包中SEQ=x,ACK=y，发起关闭连接请求。该请求发送之后，发起方的状态变为FIN_WAIT1。
发送方此时仍然可以接收数据，如果没有等到接收方的响应包，可以重发这个请求。

2. **第二次挥手：** 接受方接收到[FIN,ACK]数据包，向客户端发送确认包，数据包的内容是[ACK] seq=y ack=x+1此接受方处于CLOSE_WAIT状态，发送方处于FIN_WAIT2状态

3. **第三次挥手：** 发送方接收到接受方的确认包，再次发送关闭连接数据包[FIN,ACK] seq=z ack=x+1以关闭连接。
   此时发送方处于TIME_WAIT状态，接受方处于LASTACK状态。

4. **第四次挥手：** 接受方接收到发送方再次发送的FIN数据包，以及上一次确认包，一样发送一个 ACK 报文作为应答，且把发送方的序列号值 + 1 作为自己 ACK 报文的序列号值,此时连接属于TIME_WAIT状态。
   需要过一了一定时间（2MSL）之后，接收方最后再次发送一个ACK 数据包确认关闭请求，且seq=y+1 ack=z+1，此时客户端才会进入 CLOSED 状态，以确保发送方的ACK可以到达接收方，防止已失效连接请求报文段出现在此连接中。

通过抓包测试分析TCP四次挥手：
![小杜的个人图床](http://pic.xiaodu0.com//assets/uploads/20231012/57c3db7b643d3477aecc42e876742940.png)

![小杜的个人图床](http://pic.xiaodu0.com//assets/uploads/20231012/e09e700295bb3ac436cba8369d68be7c.png)

通过NGinx测试，服务端地址为101.36.125.169,本地地址为10.11.238.93，端口分别是80和62159。数据包由发送顺序逆序排序。

首先在No.242605的记录中，服务端发起一次[FIN,ACK]数据包，由80端口发送到本地62159端口，数据包内容为seq=1 ack=1 设seq值为x ack的值为y
接着本地接受到FIN数据包，作出相应，返回ACK数据包确认请求，seq=y ack=x+1
服务器接收到确认包，再次发送[FIN,ACK] 数据包，seq=z ack=x+1
最后，客户端再次接受FIN数据包，最后发送一次ACK包，seq=y+1 ack=z+1

