
## 词法分析

### 行结构

**逻辑行**：

**Python源代码文件被词法分析器解析后生成的形符流的每一行。**

NEWLINE 形符表示结束逻辑行。语句不能超出逻辑行的边界，除非句法支持 NEWLINE （例如，复合语句中的多行子语句）。根据显式或隐式 行拼接 规则，一个或多个 物理行 可组成逻辑行。


**物理行**：

> 物理行是一序列字符，由行尾序列终止。源文件和字符串可使用任意标准平台行终止序列 - Unix ASCII 字符 LF （换行）、 Windows ASCII 字符序列 CR LF （回车换行）、或老式 Macintosh ASCII 字符 CR （回车）。不管在哪个平台，这些形式均可等价使用。输入结束也可以用作最终物理行的隐式终止符。

实际上就是源代码文件中的每一行。

一般来说，为了代码更加可读和提高词法分析器的效率，建议一个物理行只对应一个逻辑行。

通俗来说，物理行就是在源代码中编写的代码所在的行数，逻辑行即词法分析器处理预编译后所在的那一行。

如果需要在一个物理行编写多个逻辑行，通过分号把语句分割开，例如：
```py
a=1;print(a)
```
等同于：
```py
a=1;print(a);
```

如果将一个逻辑行拆分为多个物理行，使用反斜杠连接：
```
a=0
b=a\
if\
a>0\
else\
-1;
```

等同于：
```py
a=0
b=a if a>0 else -1
```

### 编码声明

Python 脚本第一或第二行的注释匹配正则表达式 `coding[=:]\s*([-\w.]+) `时，该注释会被当作编码声明；这个表达式的第一组指定了源码文件的编码。编码声明必须独占一行，在第二行时，则第一行必须也是注释。编码表达式的形式如下：

`# -*- coding: <encoding-name> -*-`

同时也支持如下格式：

`# vim:fileencoding=<encoding-name>`

示例：
设定编码为GBK2312
`# -- coding: GBK2312 --`
或者
`# vim:fileencoding=GBK2312`

 没有编码声明时，默认编码为 UTF-8。此外，如果文件的首字节为 UTF-8 字节顺序标志（`b'\xef\xbb\xbf'`），文件编码也声明为 UTF-8（这是 Microsoft 的 **notepad** 等软件支持的形式）。

### 关键字

在python3.10版本之后加入了软关键字，`例如match`、`type`、`_`、`case`等被作为软关键字，他们只有在特定的上下文下才被作为保留关键字。

其中`type`是在3.12版本之后加入的。

即使是软关键字，也不建议作为普通标志符使用。

### 字面值

字面值是内置类型常量值的表示法。

python的字面值可以通过单引号 `'`和双引号`"`以及连续的三个单引号或者双引号`"""，'''`表示。

- 在字符串前加上b或者B作为前缀则此时生成的类型是bytes的实例而非字符类。
```py
a = b"test"

b = """测试"""

print(type(b))

print(type(a))

'''
<class 'str'>
<class 'bytes'>
'''
```

- 在字符串前加上`r`或者`R`表示原始字符串。原始字符串中\不作为转义符。
	因此，原始字符串不转义 `'\U'` 和 `'\u'`。与 Python 2.x 的原始 unicode 字面值操作不同，Python 3.x 现已不支持 `'ur'` 句法。

- 前缀为 `'f'` 或 `'F'` 的字符串称为 _格式字符串_。`'f'` 可与 `'r'` 连用，但不能与 `'b'` 或 `'u'` 连用，因此，可以使用原始格式字符串，但不能使用格式字节串字面值。

```py
a = fr"格式化的原始字符串\n\r\u"

print(a)

# 格式化的原始字符串\n\r\u
```

### 转义序列

实际上就是转义字符串，受支持的转义字符串如下：

![小杜的个人图床](http://src.xiaodu0.com/2024/02/28/12efd297580f54c9af3206b9c59622ae.png)

下列转义字符只在字符串字面值中可用：

| 转义序列       | 含义                  |
| ---------- | ------------------- |
| \n{name}   | Unicode字符中名为name的字符 |
| \uxxxx     | 16位十六进制数xxxxx码位的字符  |
| \Uxxxxxxxx | 32位十六进制数xxx码位的字符    |
可用的字符参照：
[unicode.org/Public/15.0.0/ucd/NameAliases.txt](https://www.unicode.org/Public/15.0.0/ucd/NameAliases.txt)

注意事项：
1. 与C标准一致，\ooo最多接受三个八进制字符
2. 与C标准不同，\xhh必须为两个16进制字符，即不可为一位或者两位以上。
3. 字节串字面值中，十六进制数和八进制数的转义码以相应数值代表每个字节。_字符串_ 字面值中，这些转义码以相应数值代表每个 Unicode 字符。
4. `\uxxxx`必须为四个十六进制数码位，不满四位用0补齐。
5. `\Uxxxxxxxx`必须为八个十六进制数码位，不满八位用0补齐。

合法的示例：
```py
print("\127")
print("\xED")
print("\u2563")
print("\U0001F602")

'''
W
í
╣
😂
'''
```

### 字符串字面值合并

通过空白符分隔合并的字面值可以通过不同的引号标注合并。
```py
print("Hello"' World')

# Hello World
```

官方文档不建议这样做：*此功能在句法层面定义，在编译时实现。在运行时，合并字符串表达式必须使用 '+' 运算符。还要注意，字面值合并可以为每个部分应用不同的引号风格（甚至混用原始字符串和三引号字符串)，格式字符串字面值也可以与纯字符串字面值合并。*

### f字符串（格式化字符串）

f字符串即格式化字符串，在f字符串中可以通过`{}`标注变量和表达式来计算值。除非字面值标记为原始字符串，否则，与在普通字符串字面值中一样，转义序列也会被解码。

其他字符串字面值只是常量，格式字符串字面值则是可在运行时求值的表达式。

```python
name = "ProkingDu"

str = f"我是{name}"

print(str)

  

a = 4

b = 5

c = f"{a}*{b}的结果是：{a*b}"

print(c)

  

s=f"这里的的\\t\t将被转义为制表符"

s1=fr"这里的\t不会被转为制表符"

  

print(s,s1)

'''
我是ProkingDu
4*5的结果是：20
这里的的\t      将被转义为制表符 这里的\t不会被转为制表符
'''
```


### 数值字面值

数值字面值包括整数、浮点数和虚数，没有复数字面值，复数字面值是有整数和虚数组成的。
实际上，负数也是由一元运算符`-`和整数组成的。


**整数字面值**：

整数字面值没有长度限制，可以大到占满内存。

注意，除了 0 以外，十进制数字的开头不允许有零。以免与 Python 3.0 版之前使用的 C 样式八进制字面值混淆。

比较特殊的是，在3.6版本以后，数值字面值中可以通过下划线来使表述更加可读，在词法分析时会忽略下划线。

例如：
```
amount = 100_0000_0000
print(type(amount),amount)

# <class 'int'> 10000000000
```


### 浮点数字面值

浮点数的整数和指数部分总以 10 为基数。例如，`077e010` 是合法的，表示的数值与 `77e10` 相同。浮点数字面值的支持范围取决于具体实现。整数字面值支持用下划线分组数字。

同时浮点数字面值也可以通过下划线分割数值


### 虚数字面值

虚数字面值生成实部为 0.0 的复数。复数由一对浮点数表示，它们的取值范围相同。创建实部不为零的复数，则需添加浮点数，例如 `(3+4j)`。


```
a = 3+4j

b= 2+0.01j

c= 5

print(a+b)

print(a*5)

'''
(5+4.01j)
(15+20j)
'''
```


