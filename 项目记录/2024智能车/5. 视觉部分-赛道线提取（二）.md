
接着之前对霍夫变换提取直线之后进行更加精准的检测，首先是进行离群值过滤。

例如下图：
![小杜的个人图床](http://src.xiaodu0.com/2024/09/26/994078ed0308fc5a7b7eead27017b87e.png)

这里将远处不应该为识别为边缘的直线也给绘制了出来，将这些额外的线条视作离群值，定义一个函数用于剥离离群值，只保留斜率在平均值左右的直线。

```python
def reject_abnormal_line(raw_lines,threshold):  
    # 计算每条直线的斜率  
    slopes = [calculate_slope(line) for line in raw_lines]  
  
    # 遍历直线  
    while len(raw_lines)>0:  
        # 求均值  
        mean = np.mean(slopes)  
        # 求差  
        diff = [abs(slope - mean) for slope in slopes]  
        # 取差异最大的线条  
        idx = np.argmax(diff)  
        # print(mean,len(diff),len(raw_lines),idx)  
        if idx > threshold: # 如果最大的差异的线条斜率与斜率均值大于阈值  
            slopes.pop(idx)  
            raw_lines.pop(idx)  
        else:  
            break  
    return raw_lines
```

主要思路就是计算所有给定直线的斜率，并且循环计算均值和求每一条直线与均值的差，取斜率差值最大的直线作为参照，如果这条直线的斜率差值大于阈值，则剔除，否则表示已经没有大于阈值的直线，跳出循环。

然后返回剔除离群值的线条。

应用之后的图像：
![小杜的个人图床](http://src.xiaodu0.com/2024/09/26/a6813578f9fa2c4fb5b20d643ac553e1.png)



剔除离群值之后，由于边缘提取的线条在一条赛道线上有左右两条线条，因此要将其合并为一条线，这里用最小二乘拟合的方法。

步骤：
- 提取所有x,y的坐标组成列表，然后通过np.ravel将高维转为一维数组
- 利用np.polyfit进行直线的拟合，最终得到拟合后的直线的斜率和截距，类似y=kx+b的（k,b）
- 根据最小二乘拟合计算的多项式的系数计算直线上的点来唯一确定一条直线。

代码：
```python
def least_squires_fit(lines):  
    # 提取x，y并且转为一维数组  
    x_points = np.ravel([[line[0][0],line[0][2]] for line in lines])  
    y_points = np.ravel([[line[0][1],line[0][3]] for line in lines])  
  
    # 计算多项式系数  
    poly = np.polyfit(x_points,y_points,1)  
  
    # 根据多项式系数计算两个直线上的点  
    point_min = (np.min(x_points),np.polyval(poly,np.min(x_points)))  
    point_max = (np.max(x_points),np.polyval(poly,np.max(x_points)))  
  
    # 返回线段的端点  
    return np.array([point_min,point_max],dtype=int)
```


最小二乘拟合之后的图像：

![小杜的个人图床](http://src.xiaodu0.com/2024/09/26/05a6eb791828eaa012891cf6278fbb73.png)


