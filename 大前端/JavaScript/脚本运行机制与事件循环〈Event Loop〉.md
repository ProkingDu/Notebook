## 单线程原理

几乎在每一本JS相关的书籍中，都会说JS是单线程的，JS是通过事件队列(Event Loop)的方式来实现异步回调的。 

基本的几个概念：
- `进程`是cpu资源分配的最小单位（是能拥有资源和独立运行的最小单位）
- `线程`是cpu调度的最小单位（线程是建立在进程的基础上的一次程序运行单位，一个进程中可以有多个线程）
- 不同`进程`之间也可以通信，不过代价较大
- `单线程`与`多线程`，都是指在一个`进程`内的单和多

对于浏览器来说，浏览器是多进程的。对于计算题来说每一个应用都是一个单独的进程，
不同的应用对于功能模块或者资源的处理是不同的。有些应用通过多线程的方式处理分割开的模块，有些应用通过子进程来实现。

浏览器就是一个典型的多进程应用程序。

可以通过打开任务管理器来查看浏览器进程，浏览器进程下会存在与标签页对应的子进程。

## 浏览器的进程
浏览器包含四个主要进程：

- 主进程
	- 协调控制其他的子进程（创建，销毁）
	- 浏览器界面显示与用户交互
	- 将渲染进程（浏览器内核）得到的内存中的bitmap绘制到用户界面
	- 处理不可见操作例如网络请求等
- 第三方插件进程
	 每个插件作为一个进程，仅在使用该插件的时候才创建。
- GPU进程
	 用于3D绘图等
- 渲染进程，即 `浏览器内核`
	- 负责页面渲染，脚本运行，事件处理等
	- 每个tab页一个渲染进程。

其中最重要的也是开发者最需要关注的是渲染进程，也就是 `浏览器内核`


## 浏览器内核进程（渲染进程）

进程和线程是一对多的关系，即一个进程可以包含多个线程。

对于`渲染进程`来说，他是一个多线程的进程，其中包含的有五个主要的线程，他们分别是：
**GUI渲染进程**、**JS引擎线程**、**事件触发线程**、**定时器触发线程**、**异步http请求线程**。

### GUI渲染线程

**GUI渲染线程主要用于渲染页面**、**布局和绘制**，当**页面加载**（进程创建）时，需要绘制页面，以及刷新时 `重绘页面`和**回流**时，此进程就会执行。

**重绘页面**：
	在加载HTML文档之后通过CSS对元素进行计算以确定他的位置和大小等。

**回流：**
	当JS引擎操作DOM时，会将被操作的元素存放到队列中，并且在JS执行完成后通知渲染进程来重绘页面，称为回流。

**GUI渲染线程与JS引擎线程是互斥的**，以防止二者产生冲突的操作导致页面渲染不符合预期。

由于渲染线程主要用于页面的渲染，而同时JS引擎线程同样可以 **操作DOM**来改变页面，所以如果在执行渲染线程的同时执行JS引擎，可能会导致二者冲突的操作。

因此浏览器设置GUI渲染线程和JS引擎线程是互斥的关系，一般来说GUI渲染线程的优先级大于JS引擎线程，即当一个标签页创建（用户访问）时，首先执行渲染线程来绘制页面以符合用户需要快速加载的预期，当渲染线程执行大量的计算或者其他原因被挂起时，浏览器可能会将一些时间分配和JS引擎来保持响应性。

最终，当JS引擎执行时，渲染线程会被挂起，等待Js执行完成之后再进行渲染。

一个比较简单的例子：
```JavaScript
<p id="t">Hello World</p>
<style>
p{
font-size:15px;
position:fixed;
left:50vw;
top:50vh
}
</style>

<script>
document.querySelector("#t").innerHTML="Bye World.";
</script>
```


首先在页面加载时执行GUI渲染线程，绘制页面（p标签），并且根据css计算元素的位置来重绘标签。

接着，渲染进程完成之后被挂起，执行JS引擎，JS中有操作DOM的代码，在执行后内核（渲染进程）将其存放到队列中，当所有的JS执行完毕时，通知重GUI渲染线程来重绘页面（**回流**）。


### JS引擎线程

JS引擎进程用于 `处理解析和执行JavaScript脚本程序` 并且每个渲染进程（浏览器内核）中 **只有一个** js引擎进程（单线程）。 

JS引擎线程与GUI渲染线程是互斥的，防止渲染结果不可预期。


### 事件触发线程

用于控制**事件循环**（鼠标点击、键盘按下、ajax、setTimeout的函数）的线程，**当事件满足触发条件的时候，将事件放入JS引擎所在的执行队列中。**


### 定时器触发线程

`setInterval`与`setTimeout`所在的线程。定时任务的计时是由**定时触发线程**来计时的，JS引擎线程只负责执行队列中的定时任务函数。

例如：
```
console.log("A");
setTimeout(function(){
	console.log("C");
},0);
console.log("B")
```

上面的代码首先进行的是JS引擎线程，在JS引擎中先输出A再创建定时器，将定时器内触发输出C的函数存放在执行队列中，并且将定时器添加到定时器触发线程中来计时，计时完成后通知JS引擎执行队列中的任务。

作用：**为定时任务计时以及将计时完成后需要执行的任务插入JS引擎的执行队列中**

### 异步http请求线程

- 浏览器有一个单独的线程用于处理AJAX请求
- 当请求完成时，若有回调函数，通知事件触发线程



### JavaScript是单线程的原因

首先是历史原因，在创建 javascript 这门语言时，多进程多线程的架构并不流行，硬件支持并不好。

其次是因为多线程的复杂性，多线程操作需要加锁，编码的复杂性会增高。

而且，如果同时操作 DOM ，在多线程不加锁的情况下，最终会导致 DOM 渲染的结果不可预期。


## 事件循环

**事件循环实际上就是JS引擎线程不断执行需要执行的任务和定时器触发线程与事件触发线程将需要执行的任务插入到JS引擎线程的任务队列的过程。**

