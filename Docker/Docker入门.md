
## Docker的应用场景

### 配置简化

Docker可以大大的简化项目部署和迁移以及配置的过程，通过将应用的所有配置写入 `DockerFile`创建好镜像之后就可以在不同的平台快速部署应用，实现了一次打包，多次部署。

### 代码流水线管理

应用从开发管理到测试环境和生产环境往往需要经过复杂的流程，通过Docker可以实现 **线上线下一致的环境**，从而使开发人员和测试人员只需要关注项目代码即可，使代码的流水线管理非常简单和安全。

### 快速部署

在虚拟机之前，引入新的硬件资源需要很长的时间，而通过Docker将应用封装为镜像之后，只需要启动容器进程而非操作系统即可快速部署应用。这一个过程往往只需要几分钟的时间。

### 应用隔离

资源隔离对于提供共享hosting的公司是一个强需求。如果通过传统的虚拟机方式，虽然隔离的非常彻底，但是部署的密度就降低了，容易增加运维成本。

Docker容器充分的利用了Linux内核提供的namespace资源隔离，结合Cgroups，可以方便的设置每个容器的资源配合，并且针对不同级别的客户提供不同的资源配额。

> Cgroups全程Control Groups，是Linux内核提供的物理资源隔离机制，通过Cgroups可以实现对Linux系统下的进程或者进程资源的限制、隔离和统计功能。
> 参见： https://zhuanlan.zhihu.com/p/81668069?utm_id=0


### 服务器资源整合

正如VM对服务器的资源整合，Docker的应用隔离能力也使得Docker可以对服务器的资源进行整合，并且由于 **Docker没有额外的操作系统占用** ，并且可以 **在不同的实例之间共享没有分配的内容** ，所以Docker可以提供比VM更好的服务器资源整合方案，通过Docker可以有效的提高服务器的资源利用率。

### 多版本混合部署

由于产品的不断更新迭代，在服务器上部署不同的版本的应用或者不同的应用是一个常见的问题，对于这些不同的版本或者不同的应用，在一台服务器上同时部署往往会产生文件路径或者端口冲突的问题。

通过Docker可以很好的解决这个问题，由于Docker的每个容器的文件系统都是相对独立的，所以不必担心路径冲突的问题，而对于端口占用的问题，只需要在容器实例启动的时候选择不同的端口即可。

### 版本升级回滚

对应用程序的升级更新往往不止更新源程序，经常还会对应用的依赖项升级，传统的应用管理方式对版本进行回滚针对依赖的回滚是一个棘手的问题，但是通过Docker即可非常方便的管理。

在对应用升级时，只需要创建一个新的镜像，升级时先停用旧的容器，启动新的容器，如果需要版本回滚，即停用新的容器，切换回旧的容器即可。


### 内部开发环境

在容器技术出现之前，开发人员往往使用一个或者多个虚拟机开进行开发测试，实际上开发测试环境的资源占用非常小，大多数的资源都被虚拟机本身的进程占用了。

Docker没有额外的CPU和资源占用，因此使用Docker相比虚拟机能够更加节省开发测试的资源成本。并且Docker可以很方便的在内部进行共享，因此在提升规范性上也有很大的帮助。


## Docker的简介


### 关于Docker

Docker是一个开源的 **应用容器引擎** ，让开发者可以打包他们的应用以及依赖包到一个可抑制的容器中，然后发布到任何流行的Linux机器上，也可以实现虚拟化。容器完全使用沙盒机制，相互之间 **不会存在任何接口** 。**几乎没有性能开销**，可以很容易的在机器和数据中心运行。最重要的是，他们 **不依赖于任何语言**、**框架或者包装系统**。

Docker是dotCloud公司开源的一个基于LXC的高级容器引擎，源码托管在Github上，基于go语言并且遵从Apache2.0协议开源。

### Docker容器技术与虚拟机的区别


首先是相同点，不管是Docker容器技术还是虚拟机，都是虚拟化技术，

不同点在于，虚拟机技术需要通过Hypervisor来虚拟化硬件资源，并且在不同的虚拟机基于主机操作系统来建立虚拟机操作系统，再在虚拟机系统上运行实例。

而Docker则是直接在主机操作系统上通过Docker引擎即容器引擎来创建不同的容器运行实例，这里容器并不会占用额外的物理资源。

虚拟机结构：
![小杜的个人图床](http://src.xiaodu0.com/2024/03/11/c5b5271defe97edc20733e2237905bc1.png)

Docker的结构：
![小杜的个人图床](http://src.xiaodu0.com/2024/03/11/1f7e2cd9696122aa6b9c5c0935faa02e.png)


**docker相较于VM的优点**：  
1、比VM小、快，Docker容器的尺寸减小相比于整个虚拟机大大简化了分布  
到云和分发时间的开销。Docker启动一个容器实例时间仅仅需要几秒钟。

2、Docker是一个开放的平台，构建、发布和运行分布式应用程序。

3、开发人员不需要关系具体是哪个Linux操作系统

4、Google、微软（azure）、亚马逊、IBM等都支持docker。

5、Docker支持Unix/Linux操作系统，也支持Windows和Mac。

### Docker的局限性

Docker用于应用程序时是最有用的，但并不包含数据。日志、数据库等通常放在Docker容器外。一个容器的镜像通常都很小，不用和存储大量数据，存储可以通过外部挂载等方式使用，比如：NFS、ipsan、MFS等 ，或者docker命令 ，-v映射磁盘分区。
总之，docker只用于计算，存储交给别人。


## Docker的基本概念

Docker最重要的三个概念是：**容器**、**镜像**、**仓库**

### 镜像

我们都知道，操作系统分为 `内核` 和 用户空间。对于 Linux 而言，内核启动后，会挂载 `root` 文件系统为其提供用户空间支持。而 Docker 镜像（Image），就相当于是一个 root 文件系统。比如官方镜像 `ubuntu:18.04` 就包含了完整的一套 Ubuntu 18.04 最小系统的 root 文件系统。

Docker 镜像 是一个特殊的文件系统，除了提供容器运行时所需的程序、库、资源、配置等文件外，还包含了一些为运行时准备的一些配置参数（如匿名卷、环境变量、用户等）。镜像 `不包含` 任何动态数据，其内容在构建之后也不会被改变。



由于镜像是一个包含操作系统的完整文件系统，所以他往往是庞大的，因此在镜像设计时充分采用了 `Union FS` 的技术，将其储存为分层的文件架构。所以严格来说镜像并不是类似ISO那样的打包文件，而是由一组文件系统组成的，或者说是由多组文件系统分层组成的。


镜像构建时，会一层层构建，前一层是后一层的基础。每一层构建完就不会再发生改变，后一层上的任何改变只发生在自己这一层。比如，删除前一层文件的操作，实际不是真的删除前一层的文件，而是仅在当前层标记为该文件已删除。在最终容器运行的时候，虽然不会看到这个文件，但是实际上该文件会一直跟随镜像。因此，在构建镜像的时候，需要额外小心，每一层尽量只包含该层需要添加的东西，任何额外的东西应该在该层构建结束前清理掉。


### 容器

镜像和容器的关系，就像面向对象开发中的类和对象的关系一样，镜像是一个静态的概念，镜像被创建后不再被修改（除非重新创建镜像）。而容器就是镜像的实例，容器是一个动态的运行时的概念。

容器可以被创建、销毁、启动、停止、暂停。

容器的实质是一个进程，但是与直接运行在宿主环境上的进程不同，容器进程运行时有自己独立的 **命名空间** 。因此容器可以有自己的 **`root`文件系统**、**独立的网络配置**、**进程空间**、甚至用户ID空间。

容器内的进程是运行在一个隔离的环境里，使用起来，就好像是在一个独立于宿主的系统下操作一样。这种特性使得容器封装的应用比直接在宿主运行更加安全。也因为这种隔离的特性，很多人初学 Docker 时常常会混淆容器和虚拟机。

容器与镜像一样都是 **分层储存** 的，每一个容器运行时，是以镜像为基础创建一个新的储存层，这个为镜像运行时的读写而做准备的储存层称为 **容器储存层**

需要注意的是：

**容器储存层的生命周期与容器的生命周期一致。** 当容器被创建时，容器储存层也被创建，当容器被销毁时，容器储存层也被销毁，其中的信息也会丢失。

应此 **不应该向容器储存层写入任何数据**，按照Docker最佳实践的要求，容器储存层应当保持 **无状态化**。对于文件的读写应当使用数据卷或者绑定宿主目录，通过数据卷和宿主目录对文件进行读写，在这些位置的读写会 **跳过容器存储层** ，直接对宿主（或网络存储）发生读写，其性能和稳定性更高。

数据卷是 **独立与容器而存在的**。当容器被销毁时，数据卷的信息不会被删除。

### 仓库

当镜像构建完之后，很容易就可以在宿主机上运行。但是如果需要再其他主机运行，就需要一个 **集中储存分发镜像的服务**。

**Docker** **Registry** 就提供了这种服务，在一个Docker Registry中，可以包含多个仓库（Repository），每个仓库有不同的标签（Tag），每个标签对应一个镜像。

通常每个仓库中包含 **镜像的不同版本**，使用标签对他们进行划分各个版本，通过 `<Repository>:<Tag>`的形式访问具体标签对应的镜像，如果不指定Tag，则以 `latest` 为默认值。

以Centos为例，如果需要访问Centos7.9的镜像：
`Centos:7.9`

如果忽略了标签，则是访问Centos最新版本的镜像，等同于：**Centos:latest**

仓库名经常以 *两段式命名* 的形式出现，例如：
```
ProkingDu/Picbed
```

他们是由公开的Docker Registry的用户名和仓库名组成的。

### Docker Registry 公开服务

Docker Registry 公开服务是开放给用户使用、允许用户管理镜像的 Registry 服务。一般这类公开服务允许用户免费上传、下载公开的镜像，并可能提供收费服务供用户管理私有镜像。

最常使用的 Registry 公开服务是官方的 **Docker Hub**，这也是默认的 Registry，并拥有大量的高质量的 官方镜像。除此以外，还有 **Red Hat** 的 *Quay.io*；**Google** 的 *Google Container Registry*，**Kubernetes** 的镜像使用的就是这个服务；代码托管平台 **GitHub** 推出的 *ghcr.io*。


由于某些原因，在国内访问这些服务可能会比较慢。国内的一些云服务商提供了针对 **Docker** **Hub** 的镜像服务（**Registry** **Mirror**），这些镜像服务被称为 **加速器**。常见的有 **阿里云加速器**、**DaoCloud** 加速器 等。使用加速器会直接从国内的地址下载 **Docker** **Hub** 的镜像，比直接从 **Docker** **Hub** 下载速度会提高很多。

国内也有一些云服务商提供类似于 **Docker** **Hub** 的公开服务。比如 **网易云镜像服务**、**DaoCloud** **镜像市场**、**阿里云镜像库** 等。




### 私有Docker Registory

除了使用公开服务外，用户还可以在本地搭建私有 Docker Registry。Docker 官方提供了 Docker Registry 镜像，可以直接使用做为私有 Registry 服务。

开源的 **Docker** **Registry** 镜像只提供了 **Docker** **Registry** **API** 的服务端实现，足以支持 docker 命令，不影响使用。但不包含图形界面，以及镜像维护、用户管理、访问控制等高级功能。

除了官方的 Docker Registry 外，还有第三方软件实现了 Docker Registry API，甚至提供了用户界面以及一些高级功能。比如，**Harbor** 和 **Sonatype** **Nexus**。