
由于去年车子的舵机坏了，现在换了新的舵机，然后去年比赛用的内存卡也丢了找不到了，所以现在一切的工作都需要重新开始。

现在找了个新的内存卡，烧录镜像之后装到车上，这里碰到一个问题，怎么配置wpa_supplicant.conf文件都无法连接电脑的网络，周转半天之后发现是配置文件的内容和格式错误，正确的配置文件内容：
```python
ctrl_interface=DIR=/var/run/wpa_supplicant GROUP=netdev
update_config=1
country=CN
freq_list=2412 2417 2422 2427 2432 2437 2442 2447 2452 2457 2462 2467 2472 5745 5765 5785 5805 5825 5320 5300 5280 5260 5240 5220 5200 5180
network={
 ssid="ProkingDu"
 psk="88888888"
 key_mgmt=WPA-PSK
}
```

能连接到电脑的热点就能登录树莓派终端了，已经安装好Python了，但是没有pip工具，安装一下就好。

然后尝试调试舵机，这里卡了很久，去年对舵机控制使用的都是pigpio库来发送pwm信号，但是用去年的代码测试舵机却没有反应。

先安装pigpio:
```
sudo apt-get install pigpio
pip3 install pigpio
```

然后启动pigpio进程：
```
sudo pigpiod
```

防止冲突我在每次启动的时候都加入了重启pigpio的指令：
```
close_io = "sudo killall pigpiod"
open_io = "sudo pigpiod"
os.system(close_io)
os.system(open_io)
```

然后测试舵机：
```python
servo_pin = 12
pi = pigpio.pi()
pi.set_PWM_frequency(serco_pin,50)  # 设置pwm信号频率为50HZ
pi.set_PWM_range(servo_pin,100) # 指定信号范围
pi1.set_PWM_dutycycle(servo_pin,angleToDutyCycle(85))  # 设置占空比
```

然后奇怪的事情发生了，舵机没有任何反应。去年使用的针脚就是12号针脚，一开始我没想到这个原因然后去检查接线是不是有问题，这里车子已经被拆开了还没有装回去：

![小杜的个人图床](http://src.xiaodu0.com/2024/09/20/3dec7e7baf0331c6baaf2d5c2f3c9344.jpg)

这里怎么检查也没发现接线的问题，舵机接线也是正常的，我前后将所有的公线都尝试接入到舵机的母线测试都没有反应，这时候有点迷了。

然后就挨个测试针脚编号，从1到20都测试了舵机还是没有反应，后面考虑是不是系统的问题，然后用来另一张已经安装好系统的内存卡测试，还是不对。

然后我在网上找到了同款舵机的一篇文章：
[实例4：树莓派GPIO控制舵机转动_树莓派控制舵机-CSDN博客](https://blog.csdn.net/m0_56661101/article/details/129118301)

![小杜的个人图床](http://src.xiaodu0.com/2024/09/20/18baf50b78f1f63542815bb027f0074d.png)

这里注意到接线方式，再查一下树莓派引脚分布图：
![小杜的个人图床](http://src.xiaodu0.com/2024/09/20/86b754078ac6e4d0d384a5e5816097ba.png)

对着我现在的接线看：
![小杜的个人图床](http://src.xiaodu0.com/2024/09/20/f40c385727b8bdf0d8c9f9b4656ca80d.jpg)

这里棕色的也是GND、黄色的是SIG、红色的是VCC，这里没什么问题。

然后我尝试用RPI.GPIO库来指定这三个线的针脚来控制舵机，从引脚分布图上查到黄色的线是接在16号物理引脚、23号GPIO引脚上的，偷了上面同款舵机的代码，然后改下针脚编号：
```python
#!/usr/bin/python
# coding:utf-8
# servo_PWM_GPIO.py
# 树莓派GPIO控制外部舵机来回摆动，角度范围为0~180°，周期为4秒。
try:
    import RPi.GPIO as GPIO
except RuntimeError:
    print("Error importing RPi.GPIO!  This is probably because you need superuser privileges. "
          " You can achieve this by using 'sudo' to run your script")
import time


def servo_map(before_value, before_range_min, before_range_max, after_range_min, after_range_max):
    """
    功能:将某个范围的值映射为另一个范围的值
    参数：原范围某值，原范围最小值，原范围最大值，变换后范围最小值，变换后范围最大值
    返回：变换后范围对应某值
    """
    percent = (before_value - before_range_min) / (before_range_max - before_range_min)
    after_value = after_range_min + percent * (after_range_max - after_range_min)
    return after_value


GPIO.setmode(GPIO.BOARD)  # 初始化GPIO引脚编码方式
servo_SIG = 16
servo_VCC = 2
servo_GND = 14
servo_freq = 50
servo_time = 0.01
servo_width_min = 2.5
servo_width_max = 12.5
# servo_degree_div =servo_width_max - servo_width_min)/180
GPIO.setup(servo_SIG, GPIO.OUT)
# 如果你需要忽视引脚复用警告，请调用GPIO.setwarnings(False)
# GPIO.setwarnings(False)
servo = GPIO.PWM(servo_SIG, servo_freq)  # 信号引脚=servo_SIG 频率=servo_freq in HZ
servo.start(0)
servo.ChangeDutyCycle((servo_width_min+servo_width_max)/2)  # 回归舵机中位
print('预设置完成，两秒后开始摆动')
time.sleep(2)
try:  # try和except为固定搭配，用于捕捉执行过程中，用户是否按下ctrl+C终止程序
    while 1:
        for dc in range(1, 181, 1):
            dc_trans = servo_map(dc, 0, 180, servo_width_min, servo_width_max)
            servo.ChangeDutyCycle(dc_trans)
            # print(dc_trans)
            time.sleep(servo_time)
        time.sleep(1)
        for dc in range(180, -1, -1):
            dc_trans = servo_map(dc, 0, 180, servo_width_min, servo_width_max)
            servo.ChangeDutyCycle(dc_trans)
            # print(dc_trans)
            time.sleep(servo_time)
        time.sleep(1)
except KeyboardInterrupt:
    pass
servo.stop()  # 停止pwm
GPIO.cleanup()  # 清理GPIO引脚
```

然后运行了一下，舵机能够正常转动了。这里用的是RPi.GPIO库，由于之前用的是pigpio，我考虑还是用这个库，其实这里能正常运行问题也就解决了，兜兜转转还是针脚编号没找到，由于在RPi.GPIO中的SIG是物理引脚的编号，而在pigpio中需要指定的针脚实际上是GPIO编号，也就是上面引脚分布图（这个东西帮了我大忙了）的GPIO23。至于GND和VCC，相当于电源正负极了，只要树莓派通电VCC就能输出5V电压，GND就起着接地的作用，这里接哪编号是什么也都无所谓了。所以找到当前的GPIO23之后，指定针脚是23用pigpio也一样能控制舵机：
```python
servo_pin = 23
pi = pigpio.pi()
pi.set_PWM_frequency(serco_pin,50)  # 设置pwm信号频率为50HZ
pi.set_PWM_range(servo_pin,100) # 指定信号范围
pi1.set_PWM_dutycycle(servo_pin,angleToDutyCycle(85))  # 设置占空比
```

