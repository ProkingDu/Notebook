
## 对象、值与类型

在python中一切的数据都是由`对象`或者`对象间的关系`来表示的。

在 CPython 中，`id(x)` 就是存放 `x` 的内存的地址。

对象的类型决定了对象可以支持的操作，可以通过`type()`来查看对象的类型，实际上`type()`返回的类型也是一个对象。

对象分为可变对象与不可变对象，区分的依据是对象的值是否`直接可以更改`,可变对象的值是可以直接更改的，但是不可变对象不是严格的不可更改，由于存在引用关系，当一个不可变对象引用一个可变对象时，当可变对象的值改变，不可变对象的值也会改变。

一个对象的可变性是由其类型决定的；例如，数字、字符串和元组是不可变的，而字典和列表是可变的。

对象绝不会被**显式地销毁**；然而，当无法访问时它们可能会被作为垃圾回收。允许具体的实现推迟垃圾回收或完全省略此机制 --- 如何实现垃圾回收是实现的质量问题，只要可访问的对象不会被回收即可。

有些对象包含对其他对象的引用；它们被称为 _容器_。容器的例子有元组、列表和字典等。

类型会影响对象行为的几乎所有方面。

对于`不可变类型`，在产生新值时可能会创建一个新的对象，或者是对现有的可用的相同类型的对象的引用，但是这在`可变对象`中是**绝不允许的**。两个值相同的可变对象也一定会指向两个不同的对象。

很直观的例子：
当创建两个值相同的元组时，他们的内存地址是相同的，当创建两个值相同的列表时，他们的内存地址是不同的。

```
t1 = (1,2,3)

t2 = (1,2,3)

  

print(id(t1),id(t2))

  

d1=[1,2,3]

d2=[1,2,3]

print(id(d1),id(d2))

'''
4407353984 4407353984
4407298688 4407354112
'''
```

如果对上面的t2采用某种方法修改，再打印出内存地址则会发现t2的内存地址变化了，且没有对t1产生影响。


## 标准类型层级结构

### None

None类型下只有一种取值，并且通过关键字None来访问，它通常用来代表空值，且没有默认返回值的函数会返回此类型。

**None的布尔类型是False**


### NotImplemented

一个应当由双目运算特殊方法（如 [`__eq__()`](https://docs.python.org/zh-cn/3/reference/datamodel.html#object.__eq__ "object.__eq__"), [`__lt__()`](https://docs.python.org/zh-cn/3/reference/datamodel.html#object.__lt__ "object.__lt__"), [`__add__()`](https://docs.python.org/zh-cn/3/reference/datamodel.html#object.__add__ "object.__add__"), [`__rsub__()`](https://docs.python.org/zh-cn/3/reference/datamodel.html#object.__rsub__ "object.__rsub__") 等）返回的特殊值，用来表明该运算没有针对其他类型的实现。

`NotImplemented` 是 [`types.NotImplementedType`](https://docs.python.org/zh-cn/3/library/types.html#types.NotImplementedType "types.NotImplementedType") 类型的唯一实例。

常用于自定义数据类型的算数运算中的参数非本类的实例而无法进行双目运算而返回的值。

当NotImplemented被返回时，解释器会尝试对另一种类型进行反射操作，当两种类都返回所有尝试都返回 `NotImplemented`，解释器将引发适当的异常。

一个简单的例子：
```py
class Inter:  
    def __init__(self,value):  
        self.value=value  
    def __add__(self,other):  
        if not isinstance(other,Inter):  
            return NotImplemented  
        return self.value+other.value  
         
class Intee:  
    def __init__(self,value):  
        self.value=value  
    def __add__(self,other):  
        if not isinstance(other,Intee):  
            # return NotImplemented  
            pass  
        return self.value+other.value  
       
a=Inter(10)  
b=Intee(20)  
print(a+b)
```
由于b不是Inter类的实例，所以在进行运算时抛出Notimplemented，在最近的Python版本中这会产生一个TypeError


### Ellipsis

此类型只有一种取值。是一个具有此值的单独对象。此对象通过字面值 `...` 或内置名称 `Ellipsis` 访问。它的逻辑值为真。

Ellipsis是Ellipsis类的唯一实例，他表示的就是省略的意思，一般用于切片中省略切片索引或者在类型注解中省略对某个或者某些返回值的类型注解省略。

但是注意：***切片中`...`只能在切片时出现一次，且只能在左右或者中间出现。***

例如：
```python
import numpy as np  
  
data=np.random.rand(3,3,3)  


print(data[1,1,1])
// 0.7506220798226089
print(data[1,...,2]) 
// [0.70062679 0.47419978 0.96818501]
print(data[1,Ellipsis,1])  // 同上
```
创建一个三维向量，截取第二个向量中的每个子向量的第二列。

注解：
```python
class User:  
    def __init__(self, account: int | str, password: str):  
        print("登录失败")  
  
    def getInfo(self, uid: int) -> (str, int, ...):  
        return "name", 18, "19999999999"
```



### numbers.Number

numbers模块定义了数字抽象基类的的层级结构，其中逐级定义了更多的操作。 此模块中定义的类型都不可被实例化。

此类对象由数字字面值创建，并会被作为算术运算符和算术内置函数的返回结果。数字对象是不可变的；一旦创建其值就不再改变。Python 中的数字当然非常类似数学中的数字，但也受限于计算机中的数字表示方法。

- 它们是有效的数字字面值，当被传给它们的类构造器时，将会产生具有原数字值的对象。
    
- 表示形式会在可能的情况下采用 10 进制。
    
- 开头的零，除小数点前可能存在的单个零之外，将不会被显示。
    
- 末尾的零，除小数点后可能存在的单个零之外，将不会被显示。
    
- 正负号仅在当数字为负值时会被显示。

#### numbers.Integral

指整数形，即数学中的整数集合，包含正数和负数，同时有`int型`和`boolean型`
即使布尔类型表示的逻辑值是True和False，但是实际上他是整数类型的子类型，这两个值分别类似1和0。


#### numbers.Real（float）

此类对象表示机器级的双精度浮点数。其所接受的取值范围和溢出处理将受制于底层的机器架构 (以及 C 或 Java 实现)。Python 不支持单精度浮点数；支持后者通常的理由是节省处理器和内存消耗，但这点节省相对于在 Python 中使用对象的开销来说太过微不足道，因此没有理由包含两种浮点数而令该语言变得复杂。

#### numbers.Complex

此类对象以一对机器级的双精度浮点数来表示复数值。有关浮点数的附带规则对其同样有效。一个复数值 `z` 的实部和虚部可通过只读属性 `z.real` 和 `z.imag` 来获取

### 序列

序列是一组通过非负整数作为索引的有限有序集通过，可以通过`len()`来获得序列的长度。

可以通过切片将序列切割为子序列，子序列的索引也从零开始。

#### 不可变序列

不可变序列类型的对象已经创建就不允许更改。如果其中包含其他可变对象则其他可变对象可以修改，但是其直接引用的对象不可更改。

例如：
```python
list = [1,2,3,4,5,6]
t1=(2,list)
#print(t1[0]=5) error
t1[1][3]=6
print(t1)

t2 = tuple(list)

print(t2) 
# (1,2,3,6,5,6)
```

不可变序列包括`字符串`、`元组`、`字节串`。

- **字符串**
   字符串是由代表 Unicode 码位的值组成的序列。 取值范围在 `U+0000 - U+10FFFF` 之内的所有码位都可在字符串中使用。
   适用字符串的方法例如`ord()`将字符串转为对应的ASCII字符，或者`chr()`将ASCII转为字符串。通过`str.encode(编码类型)`将str转为bytes或者通过`bytes.decode()`解码。
   
- **元组**
  一个元组中的条目可以是任意 Python 对象。包含两个或以上条目的元组由逗号分隔的表达式构成。只有一个条目的元组 ('单项元组') 可通过在表达式后加一个逗号来构成 (一个表达式本身不能创建为元组，因为圆括号要用来设置表达式分组)。一个空元组可通过一对内容为空的圆括号创建。

- 字节串
  字节串对象是不可变的数组。其中每个条目都是一个 8 位字节，以取值范围 0 <= x < 256 的整型数表示。字节串字面值 (例如 `b'abc'`) 和内置的 [`bytes()`](https://docs.python.org/zh-cn/3/library/stdtypes.html#bytes "bytes") 构造器可被用来创建字节串对象。字节串对象还可以通过 [`decode()`](https://docs.python.org/zh-cn/3/library/stdtypes.html#bytes.decode "bytes.decode") 方法解码为字符串。


字符串和字节串是可以相互转化的类型，实际上对字符串通过 `encode()` 方法编码之后产生的就是字节串，对字节串进行 `decode` 得到的就是字符串。

#### 可变序列

可变序列即在创建之后仍然可以改变的序列，他们包括：**列表**、**字节数组**（bytesarray）。

由于他是可变的，所以切片不仅可以用来读取，也可以用于修改范围内的数据。

例如：
```
s = bytearray(10)
print(s)
#bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00')
print(s[3:5])
#bytearray(b'\x00\x00')
s[3:5]=b"\x3c\xc5"
print(s)
#bytearray(b'\x00\x00\x00\xf3\xc5\x00\x00\x00\x00\x00')

m="我是大帅哥".encode("utf8")
b=bytearray(m)
b[6:9]=bytearray("小".encode("utf8"))
print(b)
print(b.decode("utf8"))
```

由于字符串和bytes是不可变序列，但bytearray是可变序列，因此可以通过将字符串编码为utf8再通过utf8编码创建bytearray来对字符串某些位置进行修改，例如修改上方代码中索引位置为2的字符，由于utf8中常见的中文占据3个字节，所以在字节串数组中每三个字节为一个中文字符，如果通过b\[2:3\]修改，再转回中文会抛出解析错误，因为这时候字节串的长度不满足utf8转义的长度，所以应该是b\[2\*3:3\*3\]即b\[6:9]，通过此切片将这三个字节修改为小的utf8编码的字节串即可实现简单的字符串切片编辑。

关于字节串与字节数组：[https://docs.python.org/zh-cn/3/library/stdtypes.html#bytes](https://docs.python.org/zh-cn/3/library/stdtypes.html#bytes)

### 集合类型

集合类型是一种由 **不可重复** 且 **不可变** 的对象组成的无序且有限的数据集合，注意集合的内容是不可变的，但是 **集合是可变的**

由于集合是无序的，所以他不能通过索引来访问元素，并且集合内的元素不可编辑，但是它是 **可迭代的** 并且可以通过 `len()` 方法计算成员数量。

集合一般多用于成员的快去检测或者去除序列中的重复项。（将序列转为集合即可去除重复项）

集合可以进行标准的数学运算例如交、并、差、对称差等。

集合的不可变规则与字典的键相同（唯一性），并且集合元素的比较遵循标准的比较规则，如果两个数字的值相同则他们不会出现在同一个集合（而不进行强制的类型检验）

内生集合有两种不同的类型：
- 集合
  标准的集合类型，通过 `{}`或 `set()`构造器创建集合，集合是可变的，因此可以通过 `add()`等方法操作集合。
  
 - 冻结集合
   冻结集合与标准集合相反，冻结集合的元素和集合本身都是不可变的，并且冻结集合是 hashable（可哈希的），因此 **冻结集合也可用作集合的组成部分**或者是字典的键。（相反， **可变对象则不能作为集合的元素** ，例如字典和列表。）
   如果在集合里放入可变对象，则会报出对象不可哈希的错误。
   冻结集合通过内置的`forzenset()`构造器构造。


#### 集合的操作

由于两种内生集合的差异性（可变与不可变），所以对于集合的操作应分为共用的与独特的。

**集合与冻结集合共用的操作**：
1. len()
2