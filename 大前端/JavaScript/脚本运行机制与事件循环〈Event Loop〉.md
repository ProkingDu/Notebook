## 单线程原理

几乎在每一本JS相关的书籍中，都会说JS是单线程的，JS是通过事件队列(Event Loop)的方式来实现异步回调的。 

基本的几个概念：
- `进程`是cpu资源分配的最小单位（是能拥有资源和独立运行的最小单位）
- `线程`是cpu调度的最小单位（线程是建立在进程的基础上的一次程序运行单位，一个进程中可以有多个线程）
- 不同`进程`之间也可以通信，不过代价较大
- `单线程`与`多线程`，都是指在一个`进程`内的单和多

对于浏览器来说，浏览器是多进程的。对于计算题来说每一个应用都是一个单独的进程，
不同的应用对于功能模块或者资源的处理是不同的。有些应用通过多线程的方式处理分割开的模块，有些应用通过子进程来实现。

浏览器就是一个典型的多进程应用程序。

可以通过打开任务管理器来查看浏览器进程，浏览器进程下会存在与标签页对应的子进程。

## 浏览器的进程
浏览器包含四个主要进程：

- 主进程
	- 协调控制其他的子进程（创建，销毁）
	- 浏览器界面显示与用户交互
	- 将渲染进程（浏览器内核）得到的内存中的bitmap绘制到用户界面
	- 处理不可见操作例如网络请求等
- 第三方插件进程
	 每个插件作为一个进程，仅在使用该插件的时候才创建。
- GPU进程
	 用于3D绘图等
- 渲染进程，即 `浏览器内核`
	- 负责页面渲染，脚本运行，事件处理等
	- 每个tab页一个渲染进程。

其中最重要的也是开发者最需要关注的是渲染进程，也就是 `浏览器内核`


## 浏览器内核进程（渲染进程）

进程和线程是一对多的关系，即一个进程可以包含多个线程。

对于`渲染进程`来说，他是一个多线程的进程，其中包含的有五个主要的线程，他们分别是：
**GUI渲染进程**、**JS引擎线程**、**事件触发线程**、**定时器触发线程**、**异步http请求线程**。

### GUI渲染线程

**GUI渲染线程主要用于渲染页面**、**布局和绘制**，当**页面加载**（进程创建）时，需要绘制页面，以及刷新时 `重绘页面`和**回流**时，此进程就会执行。

**重绘页面**：
	在加载HTML文档之后通过CSS对元素进行计算以确定他的位置和大小等。

**回流：**
	当JS引擎操作DOM时，会将被操作的元素存放到队列中，并且在JS执行完成后通知渲染进程来重绘页面，称为回流。

**GUI渲染线程与JS引擎线程是互斥的**，以防止二者产生冲突的操作导致页面渲染不符合预期。

由于渲染线程主要用于页面的渲染，而同时JS引擎线程同样可以 **操作DOM**来改变页面，所以如果在执行渲染线程的同时执行JS引擎，可能会导致二者冲突的操作。

因此浏览器设置GUI渲染线程和JS引擎线程是互斥的关系，一般来说GUI渲染线程的优先级大于JS引擎线程，即当一个标签页创建（用户访问）时，首先执行渲染线程来绘制页面以符合用户需要快速加载的预期，当渲染线程执行大量的计算或者其他原因被挂起时，浏览器可能会将一些时间分配和JS引擎来保持响应性。

最终，当JS引擎执行时，渲染线程会被挂起，等待Js执行完成之后再进行渲染。

一个比较简单的例子：
```JavaScript
<p id="t">Hello World</p>
<style>
p{
font-size:15px;
position:fixed;
left:50vw;
top:50vh
}
</style>

<script>
document.querySelector("#t").innerHTML="Bye World.";
</script>
```


首先在页面加载时执行GUI渲染线程，绘制页面（p标签），并且根据css计算元素的位置来重绘标签。

接着，渲染进程完成之后被挂起，执行JS引擎，JS中有操作DOM的代码，在执行后内核（渲染进程）将其存放到队列中，当所有的JS执行完毕时，通知重GUI渲染线程来重绘页面（**回流**）。


### JS引擎线程

JS引擎进程用于 `处理解析和执行JavaScript脚本程序` 并且每个渲染进程（浏览器内核）中 **只有一个** js引擎进程（单线程）。 

JS引擎线程与GUI渲染线程是互斥的，防止渲染结果不可预期。


### 事件触发线程

用于控制**事件循环**（鼠标点击、键盘按下、ajax、setTimeout的函数）的线程，**当事件满足触发条件的时候，将事件放入JS引擎所在的执行栈中。**


### 定时器触发线程

`setInterval`与`setTimeout`所在的线程。定时任务的计时是由**定时触发线程**来计时的，JS引擎线程只负责执行队列中的定时任务函数。

例如：
```
console.log("A");
setTimeout(function(){
	console.log("C");
},0);
console.log("B")
```

上面的代码首先进行的是JS引擎线程，在JS引擎中先输出A再创建定时器，将定时器内触发输出C的函数存放在执行队列中，并且将定时器添加到定时器触发线程中来计时，计时完成后通知JS引擎执行队列中的任务。

作用：**为定时任务计时以及将计时完成后需要执行的任务插入JS引擎的执行队列中**

### 异步http请求线程

- 浏览器有一个单独的线程用于处理AJAX请求
- 当请求完成时，若有回调函数，通知事件触发线程



### JavaScript是单线程的原因

首先是历史原因，在创建 javascript 这门语言时，多进程多线程的架构并不流行，硬件支持并不好。

其次是因为多线程的复杂性，多线程操作需要加锁，编码的复杂性会增高。

而且，如果同时操作 DOM ，在多线程不加锁的情况下，最终会导致 DOM 渲染的结果不可预期。


## 事件循环

**事件循环实际上就是JS引擎线程不断执行需要执行的任务和定时器触发线程与事件触发线程将需要执行的任务插入到JS引擎线程的任务队列的过程。**

**JS的任务分为同步任务和异步任务**。

JS引擎会首先执行同步代码，以此产生一个执行栈，当同步代码中产生了异步任务，则通过事件触发线程和定时器触发线程管理异步任务，当异步任务达到触发条件，将异步任务存入JS引擎的任务队列中。

JS引擎线程将执行栈中所有的同步代码执行完毕，此时执行栈空闲，读取执行队列中的任务来执行。

![小杜的个人图床](http://src.xiaodu0.com/2024/02/27/3f723a4b59a1aac05f2d24ed80330f56.png)

不管是setTimeout/setInterval和XHR/fetch代码，在这些代码执行时， 本身是同步任务，而其中的回调函数才是异步任务。

当代码执行到`setTimeout/setInterval`时，实际上是`JS引擎线程`通知`定时触发器线程`，间隔一个时间后，会触发一个回调事件， 而`定时触发器线程`在接收到这个消息后，会在等待的时间后，将回调事件放入到由`事件触发线程`所管理的`事件队列`中。

当代码执行到`XHR/fetch`时，实际上是`JS引擎线程`通知`异步http请求线程`，发送一个网络请求，并制定请求完成后的回调事件， 而`异步http请求线程`在接收到这个消息后，会在请求成功后，将回调事件放入到由`事件触发线程`所管理的`事件队列`中。

当我们的同步任务执行完，`JS引擎线程`会询问`事件触发线程`，在`事件队列`中是否有待执行的回调函数，如果有就会加入到执行栈中交给`JS引擎线程`执行。


代码示例：
```javascript
//同步任务
console.log("start");
const a=Date.now();
console.log(`第一次计时：${Date.now()-a}`);

//异步任务：加载完毕事件
document.addEventListener("loadend",()=>{
console.log(`加载耗时: ${Date.now()-a}`);
});

//异步任务，定时器事件
setTimeout(()=>{
console.log(`定时器执行的时间：${Date.now()-a}`);
},1000);

//异步任务，http请求
fetch("http://www.xiaodu0.com",{
method:"get",
mode:"cors",
}).then(()=>{
console.log(`请求耗时:${Date.now()-a}`);
});

//同步任务
console.log("sync task success.");
```



总结：
**事件循环的核心就是JS引擎不断执行执行栈中的任务**，**当执行栈中的任务执行完毕就会读取执行队列中的任务到执行栈中运行**，**整个过程Js引擎只执行执行栈中的代码**，**由于异步任务会被事件触发线程向队列中插入**，**由此形成一个循环**。

## 宏任务与微任务

宏任务和微任务是异步任务的两个分类，异步任务是宏任务还是微任务，决定了他们如何运行，运行的优先级以及是否能够发起新一轮的Tick。
### 宏任务

我们将每次执行栈中执行的代码视为一次**宏任务**，在宏任务执行完毕之前**不会执行其他的任务**。当宏任务执行完之后，执行**GUI渲染进程**来绘制页面，此时JS引擎线程被挂起。

比较直观的例子是通过同步代码改变页面背景颜色。

```js
document.body.style.background="red";
document.body.style.background="blue";
document.body.style.background="gray";
document.body.style.background="green";
```

当以前代码执行完之后，页面会直接变为绿色，而没有上面其他的颜色过渡。

上面的代码在执行完毕之前都不会调用GUI渲染线程，只有宏任务执行完成后，才会接着进行GUI渲染，当GUI渲染完成后再交由JS引擎操作DOM，如此循环交替。

以上代码属于同一次宏任务，所以全部执行完才触发页面渲染，渲染时GUI线程会将所有UI改动优化合并，所以视觉效果上，只会看到页面变成灰色。

另一个例子：
```js
document.body.style.background="red";

setTimeout(()=>{
document.body.style.background="blue";
},0);
```

以上代码在执行时，页面首先是红色，然后瞬间变成蓝色。

这是由于上面的代码是两次宏任务，因为setTimeout并不是同步任务，所以在执行完改变红色的代码之后，将定时器中的回调函数通知给定时器触发线程，接着GUI渲染线程绘制页面，完成之后JS引擎线程再次启用，此时定时器触发线程已经在得到通知的时候立马将回调函数存放到任务队列中，JS引擎的执行栈为空，则执行回调函数。

所以第一次设置背景和创建定时器是一次宏任务，定时器的回调事件又是一次宏任务。

再看个例子：
```js
document.body.style.background="red";

setTimeout(()=>{
document.body.style.background="blue";
setTimeout(()=>{
document.body.style.background="black";
},0);
},0);
```

很显然这也会有明显的颜色切换，属于三次宏任务。

### 微任务

在了解微任务之前需要首先知道异步任务队列有**宏任务队列**和**微任务队列**之分。且无论是宏任务还是微任务都是异步任务，都由JS引擎执行，并且在JS引擎执行完执行栈中的任务之前GUI渲染线程都是被挂起的。


微任务与宏任务的区别：
![小杜的个人图床](http://src.xiaodu0.com/2024/02/27/4d0e5079cc2d8f1992f6301a00647956.jpg)

比较明显的区别是微任务相较于宏任务先运行，前面提到宏任务在执行完之后会直接启用GUI渲染，但是如果在宏任务执行中产生了微任务，这时候会先运行微任务再启用GUI渲染。


宏任务与微任务的循环过程：

- 执行一个`宏任务`（栈中没有就从`事件队列`中获取）
- 执行过程中如果遇到`微任务`，就将它添加到`微任务`的任务队列中
- `宏任务`执行完毕后，立即执行当前`微任务队列`中的所有`微任务`（依次执行）
- 当前`宏任务`执行完毕，开始检查渲染，然后`GUI线程`接管渲染
- 渲染完毕后，`JS线程`继续接管，开始下一个`宏任务`（从事件队列中获取）

![小杜的个人图床](http://src.xiaodu0.com/2024/02/27/4df81cc1edc9cf6dd3fe435c3db82e93.png)

